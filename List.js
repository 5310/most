module.exports = List;

var slice = Array.prototype.slice;
var emptyList = new List(noop);

/**
 * Create a list whose elements will be generated by calling generator
 * @param {function(next:function)} generator
 * @constructor
 */
function List(generator) {
	this._generator = generator;
}

// ## Consuming

/**
 * Consume all elements in the list
 * @param {function} f
 */
List.prototype.forEach = function(f) {
	return this._generator(f);
};

// ## Building

/**
 * Create an empty list
 * @returns {List}
 */
function empty() {
	return emptyList;
}
List.empty = empty;

/**
 * Create a list containing arguments as its only element
 * @param {*} a
 * @returns {List}
 */
function of(a /*, b, c...*/) {
	return arguments.length === 1
	? new List(function(next) { return next(a); }) // faster alternative
	: from(slice.call(arguments));
}
List.of = of;

/**
 * Create a list containing all the elements in array
 * @param {array} array
 * @returns {List}
 */
function from(array) {
	var a = array;
	return new List(function(next) {
		var r;
		for(var i=0; i<a.length && r !== false; i++) {
			r = next(a[i]);
		}
		return r;
	});
}
List.from = from;

/**
 * Create an infinite list where every element is x
 * @param {*} x
 * @returns {List}
 */
function repeat(x) {
	return new List(function(next) {
		var r;
		while(r !== false) {
			r = next(x);
		}
		return r;
	});
}
List.repeat = repeat;

/**
 * Generate an infinite list by applying f to x: [x, f(x), f(f(x)), ...]
 * @param {function} f
 * @param {*} x
 * @returns {List}
 */
function iterate(f, x) {
	return new List(function(next) {
		var r = next(x);
		while(r !== false) {
			r = next(x = f(x));
		}
		return r;
	});
}
List.iterate = iterate;

/**
 * Generate a range of integers
 * @param {number} a
 * @param {number} b
 * @returns {*}
 */
List.range = function(a, b) {
	if(arguments.length === 1) {
		b = Infinity;
	}
	if(a === b) {
		return of(a);
	}

	var step = a < b ? 1 : -1;
	return iterate(function(x) {
		return x + step;
	}, a).take(dist(a, b)+1);
};

function dist(a, b) {
	return Math.abs(a - b);
}

/**
 * The dual of fold (aka reduce), generates a list from x by repeatedly calling f,
 * which must return a pair [valueToAddToList, newX].
 * For example:
 *  List.unfold(function(x) { return [x, x+1]; }, 0) -> [1,2,3,4,5,...]
 * @param {function} f
 * @param {*} x
 * @returns {List}
 */
List.unfold = function(f, x) {
	var pair, cont;
	return new List(function(next) {
		while(cont !== false) {
			pair = f(x);
			x = pair[1];
			cont = next(pair[0]);
		}
		return cont;
	});
};

List.prototype.cycle = function() {
	return repeat(this).flatMap(identity);
};

List.prototype.scan = function(f, initial) {
	return this.map(function(x) {
		return initial = f(initial, x);
	});
};

// ## Extracting

List.prototype.head = function() {
	var head, nonEmpty;

	this.forEach(function(x) {
		head = x;
		nonEmpty = true;
		return false;
	});

	if(!nonEmpty) {
		throw new Error();
	}

	return head;
};

List.prototype.tail = function() {
	return this.drop(1);
};

// ## Transforming

List.prototype.map = function(f) {
	var g = this._generator;
	return new this.constructor(function(next) {
		return g(function(x) {
			return next(f(x));
		});
	});
};

List.prototype.ap = function(list) {
	return this.flatMap(function(f) {
		return list.map(f);
	});
};

List.prototype.flatMap = function(f) {
	var g = this._generator;
	return new this.constructor(function(next) {
		return g(function(x) {
			return f(x).forEach(next);
		});
	});
};

// ## Sublists

List.prototype.take = function(n) {
	var remaining = Math.max(0, n);
	return this.takeWhile(function() {
		remaining -= 1;
		return remaining >= 0;
	});
};

List.prototype.takeWhile = function(predicate) {
	var g = this._generator;
	return new this.constructor(function(next) {
		return g(function(x) {
			return predicate(x) && next(x);
		});
	});
};

List.prototype.drop = function(n) {
	var remaining = Math.max(0, n);
	return this.dropWhile(function() {
		remaining -= 1;
		return remaining >= 0;
	});
};

List.prototype.dropWhile = function(predicate) {
	var g = this._generator;
	return new this.constructor(function(next) {
		return g(function(x) {
			if(predicate !== void 0) {
				if(predicate(x)) {
					return;
				}
				predicate = void 0;
			}
			return next(x);
		});
	});
};

List.prototype.slice = function(start, end) {
	var s = this.drop(start);
	return typeof end === 'number' ? s.take(end - start) : s;
};

List.prototype.split = function(n) {
	return [this.take(n), this.drop(n)];
};

List.prototype.span = function(predicate) {
	return [this.takeWhile(predicate), this.dropWhile(predicate)];
};

// ## Entending

List.prototype.cons = function(x) {
	var g = this._generator;
	return new this.constructor(function(next) {
		return next(x) !== false && g(next);
	});
};

List.prototype.concat = function(list) {
	var g = this._generator;
	return new this.constructor(function(next) {
		return g(next) !== false && list.forEach(next);
	});
};

// ## Searching

List.prototype.find = function(f) {
	var found;
	this.forEach(function(x) {
		if(f(x)) {
			found = x;
			return false;
		}
	});
	return found;
};

List.prototype.findIndex = function(f) {
	var found = -1;
	this.forEach(function(x) {
		found += 1;
		return !f(x);
	});
	return found;
};

List.prototype.indexOf = function(x) {
	return this.findIndex(function(y) {
		return x === y;
	});
};

List.prototype.some = function(f) {
	return this.findIndex(f) !== -1;
};

List.prototype.every = function(f) {
	var result = true;
	this.forEach(function(x) {
		return result = !!f(x);
	});
	return result;
};

List.prototype.filter = function(predicate) {
	var g = this._generator;
	return new this.constructor(function(next) {
		return g(function(x) {
			return predicate(x) ? next(x) : true;
		});
	});
};

// ## Reducing

List.prototype.reduce = function(f) {
	return arguments.length === 1 ? this.foldl1(f) : this.foldl(f, arguments[1]);
};

List.prototype.foldl = function(f, initial) {
	var result = initial;
	this.forEach(function(x) {
		result = f(result, x);
	});

	return result;
};

List.prototype.foldl1 = function(f) {
	return this.tail().reduce(f, this.head());
};

List.prototype.reduceRight = function(f) {
	return arguments.length === 1 ? this.foldr1(f) : this.foldr(f, arguments[1]);
};

List.prototype.foldr = function(f, initial) {
	// Very brute force, but far more efficient than recursion in JS
	var result = [];
	this.forEach(function(x) {
		result.push(x);
	});

	return result.reduceRight(f, initial);
};

List.prototype.foldr1 = function(f) {
	// Very brute force, but far more efficient than recursion in JS
	var result = [];
	this.forEach(function(x) {
		result.push(x);
	});

	return result.reduceRight(f);
};

List.prototype.traverse = function(of, f) {
	return this.foldr(consf, of(empty()));

	function consf(tOfList, m) {
		return m.map(function(x) {
			return function(list) {
				return list.cons(f(x));
			};
		}).ap(tOfList);
	}
};

List.prototype.sequence = function(Functor) {
	return this.traverse(Functor, identity);
};

List.prototype.zip = function(list) {
	return this.zipWith(function(x, y) {
		return [x, y];
	}, list);
};

List.prototype.zipWith = function(f, list) {
	var g = this._generator;
	return new List(function(next) {
		return g(function(x) {
			var cont = next(x, list.head());
			list = list.tail();
			return cont;
		});
	});
};

List.prototype.flatten = function() {
	return this.flatMap(identity);
};

List.prototype.intersperse = function(x) {
	var g = this._generator;
	return new List(function(next) {
		var rest = false;
		return g(function(y) {
			if(rest) {
				next(x);
			} else {
				rest = true;
			}
			next(y);
		});
	});
};

List.prototype.join = function(separator) {
	if(typeof separator === 'undefined') {
		separator = '';
	}

	return this.intersperse(separator).foldl(function(joined, s) {
		return joined + String(s);
	}, '');
};

List.prototype.reverse = function() {
	return this.reduce(function(a, x) {
		return a.cons(x);
	}, empty());
};

List.prototype.toString = function() {
	return '[' + this.join(',') + ']';
};

//var emptyList = Object.create(List.prototype);
//
//emptyList.cons = of;
//emptyList.concat = identity;
//emptyList.head = function() {
//	throw new TypeError('empty list');
//};
//emptyList.take = emptyList.takeWhile = emptyList.drop = emptyList.dropWhile = emptyList.map = emptyList.flatMap = empty;

function noop() {}
function identity(x) { return x; }